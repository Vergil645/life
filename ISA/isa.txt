// ===== Registers

// set register
SET x1 128 // 1r imm

// ===== Memory

// alloca + memset 0
ALLOC_ZERO x1 1024 // 1r imm

// load (register where to place, src address offset)
LOAD x1 x2 // 2r

// store with offset (dst address , value, offset)
STORE x1 x2 x3 // 3r

// memcpy (dst address, src address, count)
MEMCPY x1 x2 1024 // 2r imm

// offset ptr
OFFSET x1 x2 x3 // 3r

// ===== Arithmetic

// add
ADD x1 x2 x3 // 3r

// add
ADDi x1 x2 128 // 2r imm

// add inplace load with offset (register, src address, offset)
ADD_ASSIGN_LOADi x1 x2 -16 // 2r imm

// sub
SUBi x1 x2 128 // 2r imm

// mul
MULi x1 x2 128 // 2r imm

// urem
REMi x1 x2 128 // 2r imm

// udiv
DIVi x1 x2 128 // 2r imm

// ===== Logic

// and
AND x1 x2 x3 // 3r

// or
OR x1 x2 x3 // 3r

// icmpeq
ICMP_EQi x1 x2 128 // 2r imm

// icmpne
ICMP_NEi x1 x2 128 // 2r imm

// inc + icmpne (++x2, x1 = (x2 != 128))
INC_NEi x1 x2 128 // 2r imm

// ===== Execution

// br with condition (cond, label)
BR_COND x1 label // 1r label

// exit
EXIT // no_args

// ===== Graphics

// simRand
RAND x1 // 1r

// simPutPixel (x, y, value)
PUT_PIXEL x1 x2 x3

// simFlush
FLUSH